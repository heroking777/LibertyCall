"""Streaming helper utilities for Google ASR."""
from __future__ import annotations

import asyncio
import logging
import queue
import threading
import time
from typing import Callable, Iterable, Optional, TYPE_CHECKING

from .google_asr_config import cloud_speech

# --- HELPER BUILD FINGERPRINT (must appear on import) ---
import os, hashlib, time


def _sha1_12(path: str) -> str:
    try:
        with open(path, "rb") as f:
            return hashlib.sha1(f.read()).hexdigest()[:12]
    except Exception:
        return "sha1_err"


HELPER_SIG = "GASR_ROUTE_V3_CALLLOG_20260128"  # ‚ÜêÂ•Ω„Åç„Å™‰∏ÄÊÑèÊñáÂ≠óÂàó„ÅßOK


try:
    _p = __file__
    _mtime = os.path.getmtime(_p)
    _sha = _sha1_12(_p)
    # logger „Åå„Åæ„Å†ÁÑ°„ÅÑÂèØËÉΩÊÄß„ÅÇ„Çã„ÅÆ„Åß print „ÅßÁ¢∫ÂÆü„Å´ /tmp/ws_sink.log „Å´ËêΩ„Å®„Åô
    print(f"[HELPER_SIG] sig={HELPER_SIG} file={_p} mtime={_mtime} sha1={_sha}", flush=True)
except Exception as e:
    print(f"[HELPER_SIG_ERR] {type(e).__name__} {e}", flush=True)
# --- /HELPER BUILD FINGERPRINT ---

KEEPALIVE_EMPTY_CHUNK_INTERVAL = 10
QUEUE_GET_TIMEOUT_SEC = 0.1

# „Äê100%Á¢∫ÂÆü„Ç¨„Éº„Éâ„Äë„Ç∞„É≠„Éº„Éê„É´ConfigÈÄÅ‰ø°Ê∏à„Åø„Éï„É©„Ç∞
_config_sent_calls = set()
_config_lock = threading.Lock()

if TYPE_CHECKING:
    from .google_asr import AudioFlowStats


class StreamRecoveryPolicy:
    def __init__(self, base_delay_sec: float = 3.0, max_delay_sec: float = 15.0) -> None:
        self.base_delay_sec = base_delay_sec
        self.max_delay_sec = max_delay_sec
        self._attempt = 0

    def next_delay(self) -> float:
        delay = min(self.base_delay_sec * (2**self._attempt), self.max_delay_sec)
        self._attempt += 1
        return delay

    def reset(self) -> None:
        self._attempt = 0


def ensure_config_first(
    audio_iter: Iterable["cloud_speech.StreamingRecognizeRequest"],
    streaming_config: "cloud_speech.StreamingRecognitionConfig",
    logger: logging.Logger,
    call_id_getter: Optional[Callable[[], str]] = None,
    flow_stats: Optional["AudioFlowStats"] = None,
) -> Iterable["cloud_speech.StreamingRecognizeRequest"]:
    call_id = call_id_getter() if call_id_getter else "unknown"
    seq = 0
    audio_count = 0
    audio_bytes = 0

    def log_req(req, note: str) -> "cloud_speech.StreamingRecognizeRequest":
        nonlocal seq
        audio_len = len(req.audio_content) if getattr(req, "audio_content", None) else 0
        req_type = "CONFIG" if getattr(req, "streaming_config", None) else ("AUDIO" if audio_len else "OTHER")
        logger.error(
            "[REQTRACE] seq=%d type=%s bytes=%d note=%s",
            seq,
            req_type,
            audio_len,
            note,
        )
        if flow_stats:
            if req_type == "CONFIG":
                flow_stats.add_req_cfg()
            elif req_type == "AUDIO" and audio_len:
                flow_stats.add_req_audio(audio_len)
        seq += 1
        return req

    def generator():
        nonlocal audio_count, audio_bytes
        logger.warning("[REQGEN] yielded_config uuid=%s", call_id)
        yield log_req(
            cloud_speech.StreamingRecognizeRequest(streaming_config=streaming_config),
            "config_prepend",
        )
        for req in audio_iter:
            audio_len = len(req.audio_content) if getattr(req, "audio_content", None) else 0
            if audio_len:
                audio_count += 1
                audio_bytes += audio_len
                if audio_count <= 10 or audio_count % 100 == 0:
                    logger.warning(
                        "[REQGEN] yielded_audio uuid=%s count=%d bytes_total=%d",
                        call_id,
                        audio_count,
                        audio_bytes,
                    )
            yield log_req(req, "audio" if audio_len else "non_audio")

        logger.warning(
            "[REQGEN] audio_iter_complete uuid=%s audio_count=%d bytes_total=%d",
            call_id,
            audio_count,
            audio_bytes,
        )

    return generator()


def build_request_generator(
    audio_queue: "queue.Queue[bytes]",
    stop_event: threading.Event,
    logger: logging.Logger,
    call_id_getter: Callable[[], str],
    keepalive_interval: int = KEEPALIVE_EMPTY_CHUNK_INTERVAL,
    queue_timeout_sec: float = QUEUE_GET_TIMEOUT_SEC,
    flow_stats: Optional["AudioFlowStats"] = None,
) -> Iterable["cloud_speech.StreamingRecognizeRequest"]:
    call_id = call_id_getter()
    
    # „Äê100%Á¢∫ÂÆü„Ç¨„Éº„Éâ„Äë„Åì„ÅÆcall_id„ÅßÊó¢„Å´Config„ÇíÈÄÅ„Å£„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    global _config_sent_calls, _config_lock
    with _config_lock:
        config_already_sent = call_id in _config_sent_calls
        if not config_already_sent:
            _config_sent_calls.add(call_id)
    
    logger.warning(
        "[REQGEN] start call_id=%s config_already_sent=%s",
        call_id,
        config_already_sent,
    )

    empty_count = 0

    audio_count = 0
    bytes_total = 0
    end_reason = "stop_event"
    last_audio_ts = 0.0
    try:
        while not stop_event.is_set():
            try:
                # „Äê„Éá„Éê„ÉÉ„Ç∞„ÄëÂèñÂæóÂæÖ„Å°ÈñãÂßã„É≠„Ç∞
                logger.debug("[GENERATOR_WAIT] Waiting for audio chunk...")
            
                # „Ç≠„É•„Éº„Åã„ÇâÈü≥Â£∞„Éá„Éº„Çø„ÇíÂèñÂæó („Çø„Ç§„É†„Ç¢„Ç¶„Éà‰ªò„Åç„Åß„Éñ„É≠„ÉÉ„ÇØÂõûÈÅø)
                chunk = audio_queue.get(timeout=queue_timeout_sec)
            
                if chunk is None:
                    logger.info("[REQGEN] received sentinel -> stop")
                    end_reason = "sentinel"
                    return
            
                # „Äê„Éá„Éê„ÉÉ„Ç∞„Äë„Éá„Éº„ÇøÂèñÂæóÊàêÂäüË®ºÊòé
                logger.warning(f"[GENERATOR_POP] Got chunk size: {len(chunk)} bytes. Yielding to Google...")
                print(
                    f"[GENERATOR_POP] Got chunk from queue, size={len(chunk)}",
                    flush=True,
                )
            
                empty_count = 0
            except queue.Empty:
                if stop_event.is_set():
                    break
                empty_count += 1
                if empty_count >= keepalive_interval:
                    empty_count = 0
                    logger.debug("[ASR_GEN] Emitting keepalive empty audio chunk")
                    yield cloud_speech.StreamingRecognizeRequest(audio_content=b"")  # type: ignore[arg-type]
                    if flow_stats:
                        flow_stats.add_req_audio(0)
                    continue

            if not isinstance(chunk, bytes) or len(chunk) == 0:
                continue
        
            # „Äê„Éá„Éê„ÉÉ„Ç∞„ÄëGoogle ASR„Å∏„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíË®òÈå≤
            logger.info(f"[ASR_REQUEST] Sending audio chunk: size={len(chunk)} bytes")
            logger.debug("[ASR_GEN] Yielding audio request")
            if flow_stats:
                flow_stats.add_deq(len(chunk))
                flow_stats.add_req_audio(len(chunk))
            yield cloud_speech.StreamingRecognizeRequest(audio_content=chunk)  # type: ignore[arg-type]
            audio_count += 1
            bytes_total += len(chunk)
            last_audio_ts = time.time()

            # „ÄêBOOT_DIAG„ÄëASRÈÄÅ‰ø°Ë®∫Êñ≠Ôºàchunk„Çµ„Ç§„Ç∫/Á¥ØË®àÔºâ
            if not hasattr(build_request_generator, '_asr_send_diag_total'):
                build_request_generator._asr_send_diag_total = 0
            build_request_generator._asr_send_diag_total += 1
            logger.warning(f"[ASR_SEND_DIAG] will_send bytes={len(chunk)} total_requests={build_request_generator._asr_send_diag_total}")

            # „Äê„Éá„Éê„ÉÉ„Ç∞„ÄëYieldÊàêÂäüË®ºÊòé
            logger.warning(f"[GENERATOR_YIELD] Yielded chunk to Google successfully.")
            print(
                f"[GENERATOR_YIELD] Yielded chunk to Google successfully.",
                flush=True,
            )
    except Exception as exc:
        end_reason = f"exception:{type(exc).__name__}"
        raise
    finally:
        logger.warning(
            "[REQGEN] end call_id=%s reason=%s audio_count=%d bytes_total=%d last_audio_ts=%s",
            call_id,
            end_reason,
            audio_count,
            bytes_total,
            f"{last_audio_ts:.3f}" if last_audio_ts else "NA",
        )


def schedule_stream_recovery(
    policy: StreamRecoveryPolicy,
    start_stream_worker: Callable[[str], None],
    stop_event: threading.Event,
    logger: logging.Logger,
    call_id: Optional[str],
) -> None:
    if not call_id:
        return
    delay = policy.next_delay()
    logger.info(
        "[ASR_RECOVERY] Scheduling restart for call_id=%s in %.1fs",
        call_id,
        delay,
    )

    def _recover_stream_worker() -> None:
        time.sleep(delay)
        if stop_event.is_set():
            return
        logger.info("[ASR_RECOVERY] Restarting ASR stream worker for call_id=%s", call_id)
        try:
            start_stream_worker(call_id)
        except Exception as recover_err:  # pragma: no cover
            logger.exception(
                "[ASR_RECOVERY] Failed to restart ASR stream worker: %s",
                recover_err,
            )

    recovery_thread = threading.Thread(target=_recover_stream_worker, daemon=True)
    recovery_thread.start()


def flush_pre_stream_buffer(
    pre_stream_buffer: bytearray,
    audio_queue: "queue.Queue[bytes]",
    logger: logging.Logger,
) -> None:
    if len(pre_stream_buffer) == 0:
        return
    buffer_copy = bytes(pre_stream_buffer)
    pre_stream_buffer.clear()
    try:
        audio_queue.put_nowait(buffer_copy)
        logger.info(
            "GoogleASR: PRE_STREAM_BUFFER_FLUSHED: len=%d bytes",
            len(buffer_copy),
        )
    except queue.Full:
        logger.warning(
            "GoogleASR: PRE_STREAM_BUFFER_FLUSH_FAILED (queue full): len=%d bytes",
            len(buffer_copy),
        )
    except Exception as exc:  # pragma: no cover
        logger.warning("GoogleASR: PRE_STREAM_BUFFER_FLUSH_ERROR: %s", exc)


def feed_audio_chunk(
    call_id: str,
    pcm16k_bytes: bytes,
    *,
    stop_event: threading.Event,
    stream_thread_getter: Callable[[], Optional[threading.Thread]],
    pre_stream_buffer: bytearray,
    pre_stream_buffer_max_bytes: int,
    debug_raw: bytearray,
    debug_max_bytes: int,
    audio_queue: "queue.Queue[bytes]",
    start_stream_worker: Callable[[str], None],
    logger: logging.Logger,
    flush_buffer: Callable[[], None],
    flow_stats: Optional["AudioFlowStats"] = None,
) -> None:
    print(
        f"[FEED_AUDIO_ENTRY] call_id={call_id} len={len(pcm16k_bytes) if pcm16k_bytes else 0}",
        flush=True,
    )
    if not pcm16k_bytes or len(pcm16k_bytes) == 0:
        return
    if stop_event.is_set():
        print(f"[FEED_AUDIO_SKIP_STOP] call_id={call_id} _stop_event is set", flush=True)
        logger.debug("[FEED_AUDIO_SKIP] call_id=%s stopped, skipping feed_audio", call_id)
        return

    stream_thread = stream_thread_getter()
    stream_running = stream_thread is not None and stream_thread.is_alive()
    print(
        "[FEED_AUDIO_STREAM_CHECK] call_id=%s stream_running=%s thread=%s alive=%s"
        % (
            call_id,
            stream_running,
            stream_thread is not None,
            stream_thread.is_alive() if stream_thread else False,
        ),
        flush=True,
    )
    logger.debug(
        "[FEED_AUDIO] call_id=%s chunk=%dB stream=%s", call_id, len(pcm16k_bytes), stream_running
    )
    try:
        import audioop

        rms = audioop.rms(pcm16k_bytes, 2)
        logger.info(
            "[STREAMING_FEED] call_id=%s len=%d bytes rms=%s",
            call_id,
            len(pcm16k_bytes),
            rms,
        )
    except Exception as exc:  # pragma: no cover
        logger.debug("[STREAMING_FEED] RMS calculation failed: %s", exc)

    if not stream_running:
        if len(pre_stream_buffer) < pre_stream_buffer_max_bytes:
            pre_stream_buffer.extend(pcm16k_bytes)
            logger.debug(
                "GoogleASR: PRE_STREAM_BUFFER: call_id=%s len=%d bytes (total=%d)",
                call_id,
                len(pcm16k_bytes),
                len(pre_stream_buffer),
            )
        else:
            logger.warning(
                "GoogleASR: PRE_STREAM_BUFFER_FULL: forcing stream start (call_id=%s)",
                call_id,
            )
            start_stream_worker(call_id)
            flush_buffer()
            stream_running = True

    if not stream_running:
        start_stream_worker(call_id)

    if len(debug_raw) < debug_max_bytes:
        remain = debug_max_bytes - len(debug_raw)
        debug_raw.extend(pcm16k_bytes[:remain])

    print(
        f"[FEED_AUDIO_QUEUE_BEFORE] call_id={call_id} queue_size={audio_queue.qsize()}",
        flush=True,
    )
    try:
        audio_queue.put_nowait(pcm16k_bytes)
        if flow_stats:
            flow_stats.add_enq(len(pcm16k_bytes))
            flow_stats.capture_chunk(pcm16k_bytes)
        print(
            f"[FEED_AUDIO_QUEUE_SUCCESS] call_id={call_id} len={len(pcm16k_bytes)} queue_size={audio_queue.qsize()}",
            flush=True,
        )
        logger.info(
            "GoogleASR: QUEUE_PUT: call_id=%s len=%d bytes",
            call_id,
            len(pcm16k_bytes),
        )
        # „ÄêÂº∑Âà∂„Éó„ÉÉ„Ç∑„É•Ë®ºÊòé„Äë„Ç≠„É•„Éº„Å∏„ÅÆ„Éó„ÉÉ„Ç∑„É•Áõ¥Âæå„Å´„É≠„Ç∞„ÇíÂàª„ÇÄ
        logger.warning(f"[FORCE_QUEUE_PUSH] Audio pushed to queue (size: {len(pcm16k_bytes)})")
    except queue.Full:
        print(
            f"[FEED_AUDIO_QUEUE_FULL] call_id={call_id} len={len(pcm16k_bytes)}",
            flush=True,
        )
        logger.warning(
            "GoogleASR: QUEUE_FULL (skipping chunk): call_id=%s len=%d bytes",
            call_id,
            len(pcm16k_bytes),
        )
    except Exception as exc:  # pragma: no cover
        print(
            f"[FEED_AUDIO_QUEUE_ERROR] call_id={call_id} error={exc}",
            flush=True,
        )
        logger.warning(
            "GoogleASR: QUEUE_PUT error (call_id=%s): %s",
            call_id,
            exc,
        )


def handle_streaming_responses(
    responses,
    *,
    logger: logging.Logger,
    ai_core,
    current_call_id: Callable[[], str],
    stream_start_time: Callable[[], Optional[float]],
    restart_flag_getter: Callable[[], bool],
    restart_flag_reset: Callable[[], None],
) -> None:
    import os
    logger.info("[GASR_RESP_LOOP] enter file=google_asr_stream_helper.py pid=%s", os.getpid())

    fallback_max_age_ms = 15000.0
    fallback_max_age_env = os.getenv("LIBERTYCALL_FINAL_FALLBACK_MAX_AGE_MS")
    if fallback_max_age_env:
        try:
            fallback_max_age_ms = float(fallback_max_age_env)
        except ValueError:
            logger.warning(
                "[GASR_FINAL_FALLBACK_CFG] invalid max age env=%s, defaulting to %.0f",
                fallback_max_age_env,
                fallback_max_age_ms,
            )
    single_utterance_mode = os.getenv("LIBERTYCALL_ASR_SIMPLE_CFG", "").lower() in {"1", "true", "yes"}

    last_nonempty_text = None
    last_nonempty_conf = 0.0
    last_nonempty_ts = None

    for response in responses:
        results_count = len(response.results) if response.results else 0
        error_code = response.error.code if response.error else None
        logger.error(
            "[GASR_RAW] got_response results=%s error_code=%s",
            results_count,
            error_code,
        )

        start_time = stream_start_time()
        if start_time and time.time() - start_time >= 280.0:
            call_id = current_call_id() or "TEMP_CALL"
            logger.warning(
                "[ASR_AUTO_RESTART] Stream duration limit approaching for call_id=%s",
                call_id,
            )

        logger.info("GoogleASR: STREAM_RESPONSE: %s", response)
        for result in response.results:
            if not result.alternatives:
                continue
            alt = result.alternatives[0]
            transcript = alt.transcript
            is_final = result.is_final
            confidence = alt.confidence if getattr(alt, "confidence", 0.0) else 0.0
            call_id = current_call_id() or "TEMP_CALL"
            safe_transcript = transcript or ""

            logger.debug(
                "[ASR_DEBUG] google_raw call_id=%s is_final=%s transcript=%r confidence=%s",
                call_id,
                is_final,
                safe_transcript,
                confidence if confidence else None,
            )
            logger.info(
                "GoogleASR: ASR_GOOGLE_RAW: final=%s conf=%.3f text=%s",
                is_final,
                confidence,
                safe_transcript,
            )
            logger.info(
                "üé§ ASR result: '%s' (final=%s, confidence=%.2f, call=%s)",
                safe_transcript,
                is_final,
                confidence,
                call_id,
            )
            text_stripped = transcript.strip() if transcript else ""

            if text_stripped:
                last_nonempty_text = text_stripped
                last_nonempty_conf = confidence
                last_nonempty_ts = time.monotonic()
                logger.info(
                    "[GASR_LAST_NONEMPTY] call_id=%s text_len=%d conf=%.3f",
                    current_call_id() or "TEMP_CALL",
                    len(last_nonempty_text),
                    confidence if confidence else 0.0,
                )

            if ai_core:
                try:
                    if not is_final:
                        backchannel_keywords = [
                            "„ÅØ„ÅÑ",
                            "„Åà„Å£„Å®",
                            "„ÅÇ„ÅÆ",
                            "„Åà„Åà",
                            "„Åù„ÅÜ",
                            "„ÅÜ„Çì",
                            "„ÅÇ„ÅÇ",
                        ]
                        if safe_transcript and len(safe_transcript.strip()) <= 6:
                            if any(keyword in safe_transcript for keyword in backchannel_keywords):
                                logger.debug(
                                    "[BACKCHANNEL_TRIGGER_ASR] Detected short utterance: %s",
                                    safe_transcript,
                                )
                                if hasattr(ai_core, "tts_callback") and ai_core.tts_callback:  # type: ignore[attr-defined]
                                    try:
                                        try:
                                            loop = asyncio.get_event_loop()
                                            loop.create_task(
                                                asyncio.to_thread(
                                                    ai_core.tts_callback,  # type: ignore[misc]
                                                    call_id,
                                                    "„ÅØ„ÅÑ",
                                                    None,
                                                    False,
                                                )
                                            )
                                        except RuntimeError:
                                            ai_core.tts_callback(call_id, "„ÅØ„ÅÑ", None, False)  # type: ignore[misc]
                                        logger.info(
                                            "[BACKCHANNEL_SENT_ASR] call_id=%s text='„ÅØ„ÅÑ'",
                                            call_id,
                                        )
                                    except Exception as err:  # pragma: no cover
                                        logger.exception(
                                            "[BACKCHANNEL_ERROR_ASR] call_id=%s error=%s",
                                            call_id,
                                            err,
                                        )

                    fn = getattr(ai_core, "on_transcript", None)
                    if fn:
                        params = {
                            "transcript": safe_transcript,
                            "is_final": is_final,
                            "confidence": confidence,
                            "call_id": call_id,
                        }
                        try:
                            if asyncio.iscoroutinefunction(fn):
                                try:
                                    loop = asyncio.get_running_loop()
                                except RuntimeError:
                                    loop = None
                                if loop and loop.is_running():
                                    loop.create_task(fn(**params))
                                else:
                                    asyncio.run(fn(**params))
                            else:
                                fn(**params)
                        except Exception:
                            logger.exception(
                                "‚ùå Error calling AICore.on_transcript call_id=%s", call_id
                            )
                    else:
                        if not getattr(handle_streaming_responses, "_warned_no_on_transcript", False):
                            logger.warning(
                                "‚ö†Ô∏è AICore.on_transcript not found. Transcripts will be dropped."
                            )
                            handle_streaming_responses._warned_no_on_transcript = True
                except Exception as err:  # pragma: no cover
                    logger.exception("GoogleASR: on_transcript Âëº„Å≥Âá∫„Åó„Ç®„É©„Éº: %s", err)

            if is_final:
                final_call_id = (
                    call_id
                    if "call_id" in locals() and call_id
                    else (current_call_id() or "TEMP_CALL")
                )
                text_len_any = len(transcript) if transcript is not None else None
                text_is_empty = not transcript or not transcript.strip()

                fallback_used = False
                if text_is_empty and last_nonempty_text and last_nonempty_ts:
                    age_ms = (time.monotonic() - last_nonempty_ts) * 1000.0
                    within_age = age_ms <= fallback_max_age_ms
                    allow_override = single_utterance_mode and not within_age
                    if within_age or allow_override:
                        transcript = last_nonempty_text
                        confidence = last_nonempty_conf
                        text_len_any = len(transcript)
                        text_is_empty = False
                        fallback_used = True
                        fallback_reason = "within_max_age" if within_age else "single_utterance"
                        logger.info(
                            "[GASR_FINAL_FALLBACK] call_uuid=%s age_ms=%.0f max_age_ms=%.0f reason=%s text_len=%d",
                            final_call_id,
                            age_ms,
                            fallback_max_age_ms,
                            fallback_reason,
                            text_len_any,
                        )
                    else:
                        logger.info(
                            "[GASR_FINAL_FALLBACK_SKIP] call_uuid=%s age_ms=%.0f max_age_ms=%.0f reason=stale",
                            final_call_id,
                            age_ms,
                            fallback_max_age_ms,
                        )

                manager = ai_core
                manager_type = type(manager).__name__ if manager else None
                manager_id = hex(id(manager)) if manager else None

                ai_core_obj = None
                ai_core_attr = "none"
                if manager:
                    if getattr(manager, "ai_core", None) is not None:
                        ai_core_obj = getattr(manager, "ai_core", None)
                        ai_core_attr = "ai_core"
                    elif getattr(manager, "_ai_core", None) is not None:
                        ai_core_obj = getattr(manager, "_ai_core", None)
                        ai_core_attr = "_ai_core"
                ai_core_type = type(ai_core_obj).__name__ if ai_core_obj else None
                ai_core_id = hex(id(ai_core_obj)) if ai_core_obj else None

                handler = None
                handler_attr = "none"
                if ai_core_obj:
                    if getattr(ai_core_obj, "_asr_stream_handler", None) is not None:
                        handler = getattr(ai_core_obj, "_asr_stream_handler", None)
                        handler_attr = "_asr_stream_handler"
                    elif getattr(ai_core_obj, "asr_stream_handler", None) is not None:
                        handler = getattr(ai_core_obj, "asr_stream_handler", None)
                        handler_attr = "asr_stream_handler"
                handler_type = type(handler).__name__ if handler else None
                handler_id = hex(id(handler)) if handler else None
                handler_has_method = bool(handler and hasattr(handler, "handle_asr_final"))

                logger.info(
                    "[GASR_FINAL_ROUTE] call_uuid=%s text_len=%s manager_type=%s manager_id=%s "
                    "has_ai_core=%s ai_core_type=%s ai_core_id=%s ai_core_attr=%s has_handler=%s handler_type=%s handler_attr=%s handler_id=%s",
                    final_call_id,
                    text_len_any,
                    manager_type,
                    manager_id,
                    int(ai_core_obj is not None),
                    ai_core_type,
                    ai_core_id,
                    ai_core_attr,
                    int(handler is not None),
                    handler_type,
                    handler_attr,
                    handler_id,
                )

                logger.info(
                    "GoogleASR: ASR_GOOGLE_FINAL: conf=%.3f text=%s",
                    confidence,
                    transcript,
                )
                logger.info('[ASR_RESULT] "%s"', transcript)

                has_manager = manager is not None
                logger.info(
                    "[GASR_FINAL] call_uuid=%s is_final=1 text=\"%s\" text_len=%d has_manager=%d",
                    final_call_id,
                    transcript,
                    len(transcript) if transcript else 0,
                    int(has_manager),
                )

                if text_is_empty:
                    logger.info("[GASR_FINAL_SKIP_EMPTY] call_uuid=%s", final_call_id)
                    continue

                # ASR final„ÇíÊó¢Â≠òËøîÁ≠î„É´„Éº„É´„Å∏Êé•ÁùÄ
                if handler_has_method and transcript and transcript.strip():
                    try:
                        logger.info(
                            "[GASR_FINAL_CALL] call_uuid=%s handler_attr=%s handler_type=%s text_len=%d",
                            final_call_id,
                            handler_attr,
                            handler_type,
                            len(transcript),
                        )
                        handler.handle_asr_final(  # type: ignore[call-arg]
                            final_call_id, transcript, confidence, source="google"
                        )
                        logger.info("[GASR_FINAL_CALL] done call_uuid=%s", final_call_id)
                    except Exception as err:
                        logger.exception(
                            "[GASR_FINAL_CALL_ERR] call_uuid=%s handler_type=%s type=%s msg=%s",
                            final_call_id,
                            handler_type,
                            type(err).__name__,
                            err,
                        )
                else:
                    if not handler:
                        reason = "no_handler"
                    elif not handler_has_method:
                        reason = "no_handle_method"
                    elif not transcript or not transcript.strip():
                        reason = "empty_text"
                    else:
                        reason = "unknown"
                    logger.info(
                        "[GASR_FINAL_CALL_SKIP] call_uuid=%s reason=%s handler_attr=%s handler_type=%s handler_has_method=%d text_len=%s",
                        final_call_id,
                        reason,
                        handler_attr,
                        handler_type,
                        int(handler_has_method),
                        len(transcript) if transcript else None,
                    )

                if fallback_used:
                    last_nonempty_text = None
                    last_nonempty_conf = 0.0
                    last_nonempty_ts = None

    if restart_flag_getter():
        call_id = current_call_id() or "TEMP_CALL"
        logger.info(
            "[ASR_AUTO_RESTART] Scheduled restart suppressed for call_id=%s",
            call_id,
        )
        restart_flag_reset()
