# LibertyCall ASR 頭切れ問題の修正まとめ

## 実施した修正内容

### 1. ASR起動タイミングの改善 ✅

**問題:**
- 最初の1〜2語がキューに入る前にストリームが開始されていない
- スレッド起動 → Google API接続 → ストリーム開始までに100〜200msの遅延

**修正内容:**
- ストリーム起動前の音声をバッファリング（最初の300msを保持）
- `feed_audio`内でストリームが起動していない場合、音声をバッファリング
- ストリーム起動後にバッファを自動的に送信

**修正ファイル:**
- `libertycall/gateway/ai_core.py`
  - `_pre_stream_buffer`を追加（最大300ms分の音声を保持）
  - `_flush_pre_stream_buffer()`メソッドを追加
  - `feed_audio()`でストリーム起動前の音声をバッファリング

### 2. RTP→PCM処理遅延の最適化 ✅

**問題:**
- `queue.put`がブロッキングで、キューが満杯の場合に遅延が発生
- キューサイズが200で不足している可能性

**修正内容:**
- キューサイズを200 → 500に増加
- `queue.put`を`put_nowait`に変更（ノンブロッキング化）
- キュー満杯時は警告してスキップ（音声ロスを最小化）

**修正ファイル:**
- `libertycall/gateway/ai_core.py`
  - キューサイズを500に増加
  - `feed_audio()`で`put_nowait`を使用

### 3. GoogleASRのaudio timeout問題の修正 ✅

**問題:**
- `request_generator_from_queue`で`timeout=0.5`秒で待機
- 音声が来ないと`continue`して空のチャンクを送らない
- Google側は音声が来ないと「Long duration elapsed without audio」エラーを返す

**修正内容:**
- timeoutを0.1秒に短縮（より頻繁にチェック）
- 10回連続で空の場合（約1秒）、空のチャンクを送ってタイムアウトを防ぐ
- Google側のタイムアウトを防ぐため、定期的に空のチャンクを送信

**修正ファイル:**
- `libertycall/gateway/ai_core.py`
  - `request_generator_from_queue()`でtimeoutを0.1秒に短縮
  - 空のチャンクを定期的に送信してタイムアウトを防ぐ

### 4. 初回シーケンス再生中のASRブロック問題の修正 ✅

**問題:**
- `initial_sequence_playing`がTrueの間はASRを完全にスキップ
- 初回シーケンス再生中にユーザーが話し始めると、その音声が失われる

**修正内容:**
- 初回シーケンス再生中でもASRストリームを起動
- 音声をバッファリング（最大1秒分）して、シーケンス再生完了後に送信
- バッファが満杯の場合は強制的に送信

**修正ファイル:**
- `gateway/realtime_gateway.py`
  - `_asr_buffer_during_initial`を追加（初回シーケンス再生中の音声をバッファリング）
  - `handle_rtp_packet()`で初回シーケンス再生中でも音声をバッファリング
  - `_tts_sender_loop()`でシーケンス再生完了後にバッファを送信

### 5. ASR_ERROR_FALLBACKの動作確認 ✅

**確認結果:**
- `_stream_worker`の例外発生 → `error_callback` → `_on_asr_error` → `tts_callback` の流れは正しい
- `tts_callback`が正しく設定されている
- エラーハンドリングは適切に実装されている

**修正ファイル:**
- 修正不要（既に正しく実装されている）

## 最終的な最適化案

### 実装済みの最適化

1. **通話開始時にストリームを事前起動**
   - ストリーム起動前の音声をバッファリング（最大300ms）
   - ストリーム起動後にバッファを自動送信

2. **最初の100〜300msの音声をバッファリング**
   - `_pre_stream_buffer`でストリーム起動前の音声を保持
   - ストリーム起動後に自動的に送信

3. **queue.putのノンブロッキング化**
   - `put_nowait`を使用してブロッキングを防ぐ
   - キュー満杯時は警告してスキップ（音声ロスを最小化）

4. **GoogleASRのtimeout処理改善**
   - timeoutを0.1秒に短縮
   - 定期的に空のチャンクを送ってタイムアウトを防ぐ

5. **初回シーケンス再生中のASR有効化**
   - シーケンス再生中でもASRストリームを起動
   - 音声をバッファリング（最大1秒分）して、シーケンス再生完了後に送信

### 追加の最適化案（将来の改善）

1. **処理時間の計測とログ出力**
   - RTP_RECV → STREAMING_FEED → STREAMING_ON_NEW_AUDIO → GoogleASR.feed_audio の各段階で処理時間を計測
   - 遅延が大きい箇所を特定して最適化

2. **非同期処理の導入**
   - `decode_ulaw`、`resample_poly`などの処理を非同期化
   - 並列処理で遅延を削減

3. **音声品質の向上**
   - WebRTC Noise Suppressorのパラメータ調整
   - 音声前処理の最適化

## 期待される効果

1. **頭切れ率の大幅な削減**
   - ストリーム起動前の音声をバッファリングすることで、最初の1〜2語が失われる問題を解決
   - 初回シーケンス再生中の音声もバッファリングすることで、ユーザーの最初の発話を確実に認識

2. **Audio Timeoutエラーの削減**
   - 定期的に空のチャンクを送ることで、Google側のタイムアウトを防ぐ
   - timeoutを短縮することで、より頻繁にチェックしてタイムアウトを防ぐ

3. **処理遅延の削減**
   - キューサイズを増加することで、キュー満杯による遅延を削減
   - ノンブロッキング化することで、ブロッキングによる遅延を削減

## テスト方法

1. **通話開始直後の発話テスト**
   - 「もしもし」「あのー」「人間と変わって」などの発話をテスト
   - 頭切れが発生しないことを確認

2. **初回シーケンス再生中の発話テスト**
   - 初回シーケンス再生中にユーザーが話し始めた場合のテスト
   - 音声がバッファリングされて後で送信されることを確認

3. **Audio Timeoutエラーの確認**
   - 長時間無音状態でのテスト
   - Audio Timeoutエラーが発生しないことを確認

4. **処理遅延の計測**
   - ログで各段階の処理時間を確認
   - 遅延が40〜70ms以内であることを確認

